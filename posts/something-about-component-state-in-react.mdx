---
title: Something About Component State in React
slug: something-about-component-state-in-react
date: 2021-08-29
tags:
  - react
---

## Don't Over Use Managed State

- **managed state**ï¼šstate that you need to explicitly manageï¼Œé€™è£¡æŒ‡çš„æ˜¯éœ€è¦æ‰‹å‹•ç®¡ç†çš„ç‹€æ…‹ï¼Œä¾‹å¦‚ useState æˆ– class component state
- **derived state:** ï¼šstate that you can compute via other states or propsï¼Œå¯ä»¥è—‰ç”±å…¶ä»–ç‹€æ…‹ (state) æˆ–å±¬æ€§ (props) æ‰€è¨ˆç®—å‡ºï¼Œä¸éœ€è¦æ‰‹å‹•æ›´æ–°çš„ç‹€æ…‹ï¼ˆé™¤äº† `getDerivedStateFromProps` [fully uncontrolled component](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html#recommendation-fully-uncontrolled-component-with-a-key)ï¼‰

é€éæ›´æ–° managed state è§¸ç™¼çš„ re-render é‡æ–°è¨ˆç®— derived stateï¼Œç¶­æŒç‹€æ…‹çš„å–®ä¸€ä¾†æºï¼Œç›¡å¯èƒ½é¿å…æ‰‹å‹•åŒæ­¥ç‹€æ…‹ï¼Œé™ä½ç¨‹å¼ç¢¼çš„è¤‡é›œæ€§

ä»¥å®˜æ–¹æ•™å­¸çš„äº•å­—éŠæˆ²ç‚ºä¾‹ [Completing the Game](https://reactjs.org/tutorial/tutorial.html#completing-the-game)

```jsx
function Board() {
  const [squares, setSquares] = React.useState(Array(9).fill(null));
  const nextValue = calculateNextValue(squares);
  const winner = calculateWinner(squares);
  const status = calculateStatus(winner, squares, nextValue);
  
  const selectSquare = (square) => {
    // const newSquares = ...
    // skip
    setSquares(newSquares);
  }
  
  const reset = () => {
    setSquares(squares.map(() => null));
  }
  
  return (
    // skip
  );
}
```

- `squares` ç‚ºç´€éŒ„éŠæˆ²ç‹€æ…‹çš„ managed state

```
[
  null, null, null,
  null, null, null,
  null, null, null,
]
```

å¦‚æœ derived state ç‚º managed stateï¼Œå®¹æ˜“å› ç‚ºéœ€è¦æ‰‹å‹•åŒæ­¥ç‹€æ…‹ï¼Œå°è‡´ç¨‹å¼ç¢¼è¤‡é›œåº¦ä¸Šå‡ï¼Œç”¢ç”Ÿä¸å¿…è¦çš„é–‹éŠ·æˆ– bug

```jsx
function Board() {
  const [squares, setSquares] = React.useState(Array(9).fill(null));
  const [nextValue, setNextValue] = React.useState(calculateNextValue(squares));
  const [winner, setWinner] = React.useState(calculateWinner(squares));
  const [status, setStatus] = React.useState(calculateStatus(winner, squares, nextValue));
  
  const selectSquare = (square) => {
    // skip
    setSquares(newSquares);
    setNextValue(newNextValue);
    setWinner(newWinner);
    setStatus(newStatus);
  }
  
  const reset = () => {
    // skip
    setSquares(squares.map(() => null));
    setNextValue(newNextValue);
    setWinner(newWinner);
    setStatus(newStatus);
  }
  
  return (
    // skip
  );
}
```

å®˜æ–¹ Blog çš„æ–‡ç«  [You Probably Don't Need Derived State](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html) æŒ‡çš„ derived stateï¼Œä¸»è¦ç‚º class component ä¸­ï¼Œé€é `getDerivedStateFromProps` lifecycle ç”¢ç”Ÿçš„ managed state

`getDerivedStateFromProps` å¯ä»¥ä¾æ“š props æ›´æ–°ï¼Œç„¡æ¢ä»¶è½‰æ›æˆå°æ‡‰çš„ class component stateï¼Œå¦‚æœ props æ²’æœ‰ç•°å‹•ï¼Œå‰‡ç¶­æŒ component internal stateã€‚å› ç‚º `this.setState()` æ­é…å…¶ä»– lifecycleï¼Œe.g. `componentWillReceiveProps`, etc...ï¼Œå¿½ç•¥æˆ–è¦†è“‹ props æ›´æ–°ï¼Œæ‰€å°è‡´ controlled componentã€uncontrolled component é–“çš„è³‡æ–™æµæ··äº‚ï¼Œèˆ‡æ­¤è™•æåˆ°çš„ derived state æœ‰äº›è¨±å·®ç•°ï¼Œä¸éåªè¦æ˜¯ state åœ¨ä½¿ç”¨ä¸Šé‚„æ˜¯ç›¡é‡éµå®ˆ

- avoid unconditionally creating managed state
- the derived state is computed from other states or props
- always have a clear data flow

## Lazy Initial State

`useState` å¯ä»¥æ¥æ”¶ä¸€å€‹ function ä½œç‚º initial stateï¼Œåªæœ‰åœ¨ component åˆæ¬¡æ¸²æŸ“æ™‚æœƒèª¿ç”¨è©² functionï¼Œè—‰æ­¤å¯ä»¥é¿å…å¾ŒçºŒ re-render æœ‰é«˜é–‹éŠ·çš„é‹ç®—ï¼ˆé›–ç„¶ä¸å¸¸ç”¨åˆ°ï¼‰

```js
const [state, setState] = useState(() => {
  const initialState = someExpensiveComputation(props);
  return initialState;
});
```

## Colocating State

ç›¡å¯èƒ½æŠŠ state æ”¾åœ¨æœ€ç›¸é—œçš„åœ°æ–¹

åœ¨å®˜æ–¹ç¯„ä¾‹ [Lifting State Up](https://reactjs.org/docs/lifting-state-up.html) ä¸­ï¼Œå› ç‚º sibling component ä¹‹é–“éœ€è¦å…±äº«ç‹€æ…‹ï¼Œæ‰€ä»¥å°‡ state æå‡è‡³ parent component

```jsx
class Calculator extends React.Component {
  constructor(props) {
    super(props);
    this.state = { temperature: '', scale: 'c' };
  }

  handleCelsiusChange = (temperature) => {
    this.setState({scale: 'c', temperature});
  }

  handleFahrenheitChange = (temperature) => {
    this.setState({scale: 'f', temperature});
  }

  render() {
    const { scale, temperature } = this.state;
    const celsius = scale === 'f' ? tryConvert(temperature, toCelsius) : temperature;
    const fahrenheit = scale === 'c' ? tryConvert(temperature, toFahrenheit) : temperature;

    return (
      <div>
        <TemperatureInput
          scale="c"
          temperature={celsius}
          onTemperatureChange={this.handleCelsiusChange}
        />
        <TemperatureInput
          scale="f"
          temperature={fahrenheit}
          onTemperatureChange={this.handleFahrenheitChange}
        />
        <BoilingVerdict celsius={parseFloat(celsius)} />
      </div>
    );
  }
}
```

å¦‚æœä¸éœ€è¦å…±äº« stateï¼Œå°‡ state ç§»è‡³å°æ‡‰çš„ component å…§ï¼Œå¯ä»¥é¿å…ä¸å¿…è¦çš„ re-redner

ç¯„ä¾‹å–è‡ª [Overreacted - Before You memo()](https://overreacted.io/before-you-memo/#solution-1-move-state-down)

```jsx
function App() {
  let [color, setColor] = useState('red');
  return (
    <div>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
      <ExpensiveTree />
    </div>
  );
}
```

move state down, if the color changes, only the `<Form />` re-renders.

```jsx
function Form() {
  let [color, setColor] = useState('red');
  return (
    <>
      <input value={color} onChange={(e) => setColor(e.target.value)} />
      <p style={{ color }}>Hello, world!</p>
    </>
  );
}

function App() {
  return (
    <div>
      <Form />
      <ExpensiveTree />
    </div>
  );
}
```

åŒæ¨£çš„æ¦‚å¿µä¹Ÿé©ç”¨æ–¼ react contextï¼Œ[Preventing rerenders with React.memo and useContext hook.](https://github.com/facebook/react/issues/15156#issuecomment-474590693)

## Lifting Component to Parent

ç¯„ä¾‹å–è‡ª [Kent C. Dodds - One simple trick to optimize React re-renders](https://kentcdodds.com/blog/optimize-react-re-renders)

æ¯æ¬¡ react component renderï¼Œjsx æœƒè¢«è½‰è­¯æˆ `React.createElement(type, [props], [...children])`ï¼Œä¸¦å¾—åˆ°æ–°çš„ react element (plain object)ï¼Œå¦‚ä¸‹æ–¹ç¤ºæ„ï¼Œreact-dom æœƒæ ¹æ“šæ–°çš„ react element ï¼Œä¸¦èˆ‡å‰æ¬¡çš„çµæœæ¯”å°æ±ºå®šéœ€è¦æ›´æ–°ç¯„åœ

```js
// some things removed for clarity
const counterElement = {
  type: 'div',
  props: {
    children: [
      {
        type: 'button',
        props: {
          onClick: increment, // this is the click handler function
          children: 'The count is 0',
        },
      },
      {
        type: Logger, // this is our logger component function
        props: {
          label: 'counter',
        },
      },
    ],
  },
}
```

`<Logger />` æ˜¯åœ¨ parent å±¤ç´šè½‰è­¯ jsx å¾Œå¾—åˆ°çš„ react elementï¼Œä¸¦ä»¥ children prop çš„æ–¹å¼å‚³å…¥ `Counter`

ç•¶ `count` æ›´æ–°å¾Œè§¸ç™¼ `<Counter />` re-renderï¼Œæ­¤æ™‚ä»¥ `props.logger` å‚³å…¥çš„ `<Logger />`ï¼Œå› ç‚º react æ¯”å°å‰æ¬¡çš„ children prop ä»ç‚ºåŒä¸€å€‹ react elementï¼Œæ•…ä¸æœƒå° `<Logger />` é€²è¡Œ re-render

```jsx
function Logger(props) {
  console.log(`${props.label} rendered`)
  return null // what is returned here is irrelevant...
}

function Counter(props) {
  const [count, setCount] = React.useState(0)
  const increment = () => setCount(c => c + 1)
  return (
    <div>
      <button onClick={increment}>The count is {count}</button>
      {props.logger}
    </div>
  )
}

ReactDOM.render(
  <Counter logger={<Logger label="counter" />} />,
  document.getElementById('root'),
)
```

é›–ç„¶é€é react memo ä¹Ÿå¯ä»¥é¿å… re-render çš„å•é¡Œï¼Œä½† memo çš„æ¯”å°ä¹Ÿæ˜¯éœ€è¦é¡å¤–çš„é–‹éŠ·ã€‚å¦‚æœæƒ…å¢ƒè¨±å¯ï¼Œç¤¾ç¾¤ä¸ŠçŸ¥åçš„å¤§ç¥ï¼Œé‚„æ˜¯å»ºè­°åˆ©ç”¨ react composition å¾æœ¬è³ªä¸Šè§£æ±ºå•é¡Œï¼Œæœ€å¾Œæ²¿ç”¨ [One simple trick to optimize React re-renders](https://kentcdodds.com/blog/optimize-react-re-renders) ä¸­çš„çµè«–

In summary, if you're experiencing performance issues, try this:

1. "Lift" the expensive component to a parent where it will be rendered less often.
1. Then pass the expensive component down as a prop.
1. You may find doing so solves your performance problem without needing to spread React.memo all over you codebase like a giant intrusive band-aid ğŸ¤•ğŸ˜‰

## Reference

[Kent C. Dodds - Don't Sync State. Derive It!](https://kentcdodds.com/blog/dont-sync-state-derive-it)

[Kent C. Dodds - useState lazy initialization and function updates](https://kentcdodds.com/blog/use-state-lazy-initialization-and-function-updates)

[Kent C. Dodds - State Colocation will make your React app faster](https://kentcdodds.com/blog/state-colocation-will-make-your-react-app-faster)

[Kent C. Dodds - One simple trick to optimize React re-renders](https://kentcdodds.com/blog/optimize-react-re-renders)

[Overreacted - Before You memo()](https://overreacted.io/before-you-memo/)

[You Probably Don't Need Derived State](https://reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html)

[Lazy initial state](https://reactjs.org/docs/hooks-reference.html#lazy-initial-state)
