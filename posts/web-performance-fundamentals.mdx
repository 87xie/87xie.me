---
title: Web Performance Fundamentals
slug: web-performance-fundamentals
tags:
  - performance
  - javascript
date: 2021-04-21
---

關於效能的議題可能涉及到系統架構、產品設計、商業模式、業務需求，甚至過去技術債等等，在各種不同層面的量子糾纏下，大多並非一時半刻就能解決，像是

- Frontend
  - 發出請求時沒處理好 Request Headers, Request Body，導致 Server 誤判造成額外開銷
  - [Async Await Hell](https://www.freecodecamp.org/news/avoiding-the-async-await-hell-c77a0fb71c4c/)
  - Rendering Issues
- Backend
  - 犧牲效能來確保安全性、資料一致性
  - 過去糟糕的 Schema 、技術債，老子改不動
- Marketing
  - 因廣告需求，在網站上把 Hero Image 大版面的圖片塞好塞滿
  - 需要多個 Analytics Tools 追蹤 Bounce Rate, Session Time, Revenue, Checkouts ... 指標
- Business Scenarios
  - 商品需要顯示購買人數的需求，是要以即時資料還是一個時間區間內的暫存資料即可，是否扣除退貨訂單數量 ... 等

綜觀來說前端只是網頁的一部分，即使面對無法立即處理的效能問題，我們也可以從其他方面下手，例如：

- 透過 UI 向用戶指示，某個區塊正在載入某種資料 (圖片、文字等 ...)，同時避免資料載入後造成非預期的版面位移
- 把較耗時的 API 、工作，移至不同階段處理 (Minimize main thread work)，提升用戶第一次與網頁互動的時間 (FID)
- 透過各種方法來分散用戶等待時的注意力，提升用戶感知效能

為什麼要重視效能

- Google 說很重要，[Speed is now a landing page factor for Google Search and Ads](https://developers.google.com/web/updates/2018/07/search-ads-speed)
- 老闆會去跟競品比較

優化的核心原則

> Do fewer things in every possible layers.

## Perceived Performance

用戶對網站速度的主觀感受，我們可以根據下列幾項原則，分散用戶在等待時的注意力，提升感知的載入時間

- People will wait for value
- Bored waits feel slower
- Anxious waits feel slower
- Unexplained waits feel slower
- Uncertain waits feel slower

常見的例子像是

- Medium (blog platform) loading low quality pictures first and then replacing them higher quality pictures.
- Skeleton loading first and replace skeleton objects immediately when the data is available. (Youtube, etc)
- Loading state designs (button state, loading dialog, spinner, etc)

## Where do we Measure from

### Lab Data

Lab data is performance data collected within a controlled environment with the predefined device and network settings. This offers reproducible results and debugging capabilities to help identify, isolate, and fix performance issues.

- Chrome Dev Tools
- Lighthouse
- [lightest.app](https://www.lightest.app/)
  - Web performance visualization and comparison tool. Analyze website loading against competitors.

### Field Data

Field data is performance data collected from real page loads your users are experiencing in the wild.

- [Chrome UX Report Compare Tool](https://crux-compare.netlify.app/)
- [PageSpeed Insights](https://developers.google.com/speed/pagespeed/insights/)

## Web Vitals

Web Vitals is an initiative by Google to provide unified guidance for quality signals that are essential to delivering a great user experience on the web.

### Time to First Bite (TTFB)

How long the browser has to wait before receiving its first byte of data from the server.

發出請求後，接收到 Server 回傳的第一個 Byte 時間，包含 TCP 連結時間、HTTP 請求時間。

Server Side Rendering 的架構，TTFB 時間很大一部分取決於 API 的效能。

#### Optimizing Metrics

- Reduce the amount of work required to render pages
- Check API calls
  - Sure it’s necessary.
  - Check query parameters, request headers, request body, .
- Maybe we don't need dynamic content.
  - Static Site / JAMstack

### First Contentful Paint (FCP)

The time until the user sees an indication that the page is loading.

（瀏覽器繪製出第一個內容的時間）

#### Optimizing Metrics

- Quick servers
  - sized correctly (e.g. have enough overhead in the machines)
  - minimal processing
  - network bandwidth
- Small documents
  - Content size
  - compression
- Short Transmission
  - depend on your infrastructure

### Largest Contentful Paint (LCP)

The time until user sees most of the page and believes it is ready.

（每當頁面出現一個比當前 LCP 更大的元素就會取代為新的 LCP，直到使用者開始和網頁互動為止。）

#### Optimizing Metrics

- Defer resources until later (We don't need right away)
  - Lazy loading, e.g.
    - loading current locale css font
    - images
    - code splitting
  - Tree shaking
- Optimize images
  - Responsive images
  - Crunching the images
- Reduce request overhead (DNS, TCP, SSL, Request, Response, Processing)
  - Cached Request
  - HTTP/2 (Reuse connection)
  - Preconnect, DNS-prefetch, e.g.
    - `<link rel="preconnect" href="https://fonts.gstatics.com">`

### Cumulative Layout Shift (CLS)

The movement distance and impact of page elements during the entire lifetime of the document the user sees.

（計算載入網頁元素時的非預期位移，像是圖片載入後造成的版面位移。像 Dropdown, Collapse 這類的網頁元素，與使用者互動後發生選項視窗彈出、內容收合發生的版面位移，則視為可預期的位移）

#### Optimizing Metrics

- CSS aspect ratio placeholder
- Never insert content above existing content, except in response to user interaction.
- Ensure the browser knows how much space to allocate for an image is simply to define its width and height, Modern browser will now take those values into consideration and remove all the jank before the image has loaded.

```html
<style>
img.is-responsive {
  width: 100%;
  height: auto;
}
</style>

<picture>
  <source srcset="~static/image/amazon.webp" type="image/webp" />
  <img
    src="~static/image/amazon.png"
    alt="毎週抽選で合計 100 名に Amazon ギフト券 1,000 円分をプレゼント！"
    width="200"
    height="126"
    loading="lazy"
    class="is-responsive"
  />
</picture>
```

### First Input Delay (FID)

The browser time delay between the user's first click and execution of application code.
（瀏覽器完成主線程後，開始執行使用者互動事件的時間）

## Get Performance Information Programmatically

下方為如何在 client side 收集真實的 web vitals，並向指定 api 端點發送資料的示意程式碼

[code resource](https://github.com/toddhgardner/perf-training-website/blob/perf-complete/public/assets/js/util/perf.js)

- `new PerformanceObserver().observe({ buffered: true })`
  - `buffered` it means give the events event if they already happended

- The `navigator.sendBeacon()` method asynchronously sends a small amount of data over HTTP to a web server.
  - not supported for all browser
  - will sending a POST request

```javascript
(function (ready) {
  if (document.readyState === "complete" || document.readyState === "interactive") {
    ready();
  } else {
    document.addEventListener("readystatechange", function() {
      if (document.readyState === "complete") {
        ready();
      }
    });
  }
})(function perf() { /* the document is now complete. */

  var data = {
    url: window.location.href,
    dcl: 0,
    load: 0,
    fcp: 0,
    lcp: 0,
    cls: 0,
    fid: 0
  };

  var fcpObserver = new PerformanceObserver(function handleFCP(entryList) {
    var entries = entryList.getEntries() || [];
    entries.forEach(function(entry) {
      if (entry.name === "first-contentful-paint") {
        data.fcp = entry.startTime;
        console.log("Recorded FCP Performance: " + data.fcp);
      }
    });
  }).observe({ type: "paint", buffered: true });

  var lcpObserver = new PerformanceObserver(function handleLCP(entryList) {
    var entries = entryList.getEntries() || [];
    entries.forEach(function(entry) {
      if (entry.startTime > data.lcp) {
        data.lcp = entry.startTime;
        console.log("Recorded LCP Performance: " + data.lcp);
      }
    });
  }).observe({ type: "largest-contentful-paint", buffered: true });

  var clsObserver = new PerformanceObserver(function handleCLS(entryList) {
    var entries = entryList.getEntries() || [];
    entries.forEach(function(entry) {
      if (!entry.hadRecentInput) {
        data.cls += entry.value;
        console.log("Increased CLS Performance: " + data.cls);
      }
    });
  }).observe({ type: "layout-shift", buffered: true });

  var fidObserver = new PerformanceObserver(function handleFID(entryList) {
    var entries = entryList.getEntries() || [];
    entries.forEach(function(entry) {
      data.fid = entry.processingStart - entry.startTime;
      console.log("Recorded FID Performance: " + data.fid);
    });
  }).observe({ type: "first-input", buffered: true });

  window.addEventListener("beforeunload", function() {
    var navEntry = performance.getEntriesByType("navigation")[0];
    data.dcl = navEntry.domContentLoadedEventStart;
    data.load = navEntry.loadEventStart;

    var payload = JSON.stringify(data);
    navigator.sendBeacon("/api/perf", payload);
    console.log("Sending performance:", payload);
  });
});
```

## Rendering Performance

### The Render Tree

Optimizing the critical rendering path is the process of minimizing the total amount of time spent performing steps in the above sequence

```mermaid
graph LR
  html_parser[HTML Parser] --> dom_tree[DOM Tree]
  css_parser[CSS Parser] --> cssom_tree[CSSOM Tree]
  dom_tree --> render_tree[Render Tree]
  cssom_tree --> render_tree
  render_tree --> layout[Layout]
  layout --> paint[Paint]
```

- Process HTML markup and build the DOM tree.
- Process CSS markup and build the CSSOM tree.
- Combine the DOM and CSSOM into a render tree.
- Run layout on the render tree to compute the exact position and size of each node.
- Paint the individual nodes to the screen.

### Reducing Render Blocking Time

Render blocking means that these JavaScript or CSS Resources are slowing down your browser parse render tree.

- Whenever the parser encounters a script it has to stop and execute it before it can continue parsing the HTML.
- CSS is a render blocking resource. Get it to the client as soon and as quickly as possible to optimize the time to first render.
- Lazy loading cause render blocking resources
- Web font (fetch & alter when content loaded, useful for chinese fonts)
- Third party library code, only load when they needed e.g. zendesk, youtube iframe sdk ....

###  Minimizing Browser Relayout

Relayout is the name of the web browser process for re-calculating the positions and geometries of elements in the document, Occurs when you

- insert, remove or update an element in the DOM
- modify content on the page, e.g. the text in an input box
- move a DOM element
- animate a DOM element
- take measurements of an element such as offsetHeight or getComputedStyle
- change a CSS style
- change the className of an element
- add or remove a stylesheet
- resize the window

### Avoid Forced Synchronous Layout (Layout Thrashing)

Layout Thrashing occurs when JavaScript violently writes, then reads, from the DOM, multiple times causing document reflows.

The browser is lazy and wants to wait until the end of current operation (or frame) to perform this reflow.

- Do not put the browser into a read-write-read-write cycle.
- Batches your reads and writes manipulate.

```javascript
// Read
var h1 = element1.clientHeight;
var h2 = element2.clientHeight;
var h3 = element3.clientHeight;

// Write (invalidates layout)
element1.style.height = (h1 * 2) + 'px';
element2.style.height = (h2 * 2) + 'px';
element3.style.height = (h3 * 2) + 'px';

// Document reflows at end of frame
```

- [fastdom](https://github.com/wilsonpage/fastdom)

## Reference 

[Frontend Masters - Web Performance Fundamentals](https://frontendmasters.com/courses/web-perf/)

[重新學習瀏覽器資源載入機制，這些年努力改善電商網站效能的旅程](https://jason-memo.dev/posts/relearn-browser-loading-resoure-improve-ec-site-performance-journey/)

[Web Vitals](https://web.dev/vitals/)

[How To Think About Speed Tools](https://developers.google.com/web/fundamentals/performance/speed-tools/)

[MDN - Perceived performance](https://developer.mozilla.org/en-US/docs/Learn/Performance/Perceived_performance)

[MDN - PerformanceObserver.observe()](https://developer.mozilla.org/en-US/docs/Web/API/PerformanceObserver/observe)

[MDN - Navigator.sendBeacon()](https://developer.mozilla.org/en-US/docs/Web/API/Navigator/sendBeacon)

[MDN - Lazy loading](https://developer.mozilla.org/en-US/docs/Web/Performance/Lazy_loading)

[Preventing 'layout thrashing'](https://blog.wilsonpage.co.uk/preventing-layout-thrashing/)

[eleventy-high-performance-blog](https://github.com/google/eleventy-high-performance-blog)
